"""
.. module:: generate_statistical_score_bars.py
   :synopsis: This script do plotting the bargraphs of the various statistical
              score versus threshold in XMGRACE.
.. moduleauthor:: Dileepkumar R <dileepkunjaai@gmail.com>,
                  Arulalan.T <arulalant@gmail.com>

Date : 04.08.2011

Updated on : 28.09.2011

"""

import os
import sys
import numpy
import numpy.ma
import cdms2
from genutil import xmgrace
# setting the absolute path of the previous directory
# getting the this py module path by __file__ variable
# pass that __file__ to the os.path.dirname, returns the path of this module
__diagnosisDir__ = os.path.dirname(__file__)
previousDir = os.path.abspath(os.path.join(__diagnosisDir__, '..'))
# adding the previous path to python path
sys.path.append(previousDir)
# importing plot.py, xml_data_acces.py, TimeUtility from previous directory
# uv_cdat_code.diagnosisutils
import uv_cdat_code.diagnosisutils.xml_data_access as xml_data_access
from uv_cdat_code.diagnosisutils.timeutils import TimeUtility
from uv_cdat_code.diagnosisutils import numutils
from diag_setup.globalconfig import models, threshold, processfilesPath, \
                               plotsgraphsPath, seasons
from diag_setup.varsdict import variables
from diag_setup.gendir import createDirsIfNotExists

# create time utility object
timobj = TimeUtility()

regions = {'CIndia': 'Central India [73-90E, 22-28N]',
            'PenIndia': 'Peninsular India [74-85E, 7-21N]',
            'WcstIndia': 'West Coast [70-78E, 10-20N]',
            'AIR': 'All India [67-100 E, 7-37N]'}


def genSeasonStatiScoreDirs(modelName, modelHour, availableMonths):
    """
    :func:`genSeasonStatiScoreDirs`: It should generate the directory hierarichy
        structure of season statiscore in the plotsgraphspath. And calls the
        function genIsoFillPlots to make 'isofill' plots and save it
        inside the appropirate directory, by reading the nc file of the
        appropirate process season hour statiscore files path.

        It should plot for all the vars of that statiscore spatial distributed
        nc files.

    Inputs : modelName is the one of the directories name.
             modelHour is the one of the directories name.
             availableMonths is the dictionary which is generated by fully
             available months from the timeAxis.

    Written By : Arulalan.T

    Date : 27.09.2011

    """

    processStatiScorePath = os.path.join(processfilesPath, modelName, 'StatiScore')
    for year in availableMonths.keys():
        # get the months dictionary
        monthdic = availableMonths.get(year)
        # sort the months in correct order
        months = timobj._sortMonths(monthdic.keys())
        year = str(year)
        processStatiSeasonPath = os.path.join(processStatiScorePath, year, 'Season')
        for seasonName, season in seasons.iteritems():
            # find out xml time axis months has the seasonal months or not
            seasonMonths = [month for smonth in season for month in months
                            if smonth[:3].lower() == month[:3].lower()]
            if len(seasonMonths) == len(season):
                print "Got the seasonal months for %s season" % seasonName
            else:
                print "Seasonal months are not available for %s season" % seasonName
                continue
            if seasonName.isupper():
                seasonName = seasonName.lower()
            proStatiSeasonChildPath = os.path.join(processStatiSeasonPath, seasonName)
            # get the process statistical score Region path
            proStatiRegionPath = os.path.join(proStatiSeasonChildPath, 'Region')
            # Do process if process stati score Region directory is exists
            if os.path.isdir(proStatiRegionPath):
                # get the available files from this directory
                files = os.listdir(proStatiRegionPath)
                if not files:
                    continue
                    # process empty directory. need to log about this.
                    # process files cant be empty, very less chance.
                # end of if not files:
                # get the nc file name
                ncfiles = [ncfile for ncfile in files if ncfile.endswith('.nc')\
                if ncfile.startswith('statistical_score')]

                if not ncfile:
                    # ncfile is none
                    print "The path %s doesnt have nc file" % proStatiRegionPath
                    print "here obtained nc file is %s" % ncfile
                    continue

                # create modelName, StatiScore, year, Season, seasonName,
                # Region directories if it is not exists
                plotSeasonRegionPath = createDirsIfNotExists(plotsgraphsPath,
                                            [modelName, 'StatiScore', year,
                                            'Season', seasonName, 'Region'])

                if not os.listdir(plotSeasonRegionPath):
                    # directory is empty. So calling below function
                    # to create all bar diagram plot image files
                    # in stati score Rgion directory of plotsgraphspath.
                    for ncfile in ncfiles:
                        # get the nc file path
                        ncPath = proStatiRegionPath + '/' + ncfile
                        genBarDiagrams(var = 'all', path = ncPath,
                                       hours = modelHour,
                                       outpath = plotSeasonRegionPath)
                    # end of for ncfile in ncfiles:
                else:
                    pass
                    # directory is non empty. Have to check either
                    # all vars plots image files are exists or not
                # end of if not os.listdir(plotSeasonRegionPath):
            else:
                pass
                # the process month name directory not created yet or
                # removed.
            # end of if os.path.isdir(proStatiRegionPath):
        # end of for month in months.keys():
    # end of for year in availableMonths.keys():
    print "Done! creation of Bar diagrams of season stati score for model %s" % modelName
# end of def genSeasonStatiScoreDirs(modelName, modelHour, availableMonths):

def genBarDiagrams(var, path, hours, outpath=None, bargap=0.28, barwidth=0.8,
                                                             yticdiff=0.25):
    """
    :func:`genBarDiagrams`: It should generate the least directory hierarichy
        structure of season statiscore in the plotsgraphspath by score name.
        It will plots score values in xmgrace as bar diagram and save it
        inside the appropirate directory, by reading the nc file of the
        appropirate process season Region statiscore files path.

        It should plot for all the vars of that statiscore nc files.

    Inputs : var is the variable name. If var is 'all' means, then it should
             plot the bar diagram for all the available variables in the passed
             path nc or xml file.

             path is an absolute nc or xml file path.

             outpath is the path to store the images. If it is None means, it
             should create the least (plotname)directory in the current
             directory path itself and save it.

             bargap is the value of the gap ratio in between each bars of each
             threshold in xaxis of score bar diagram.

             barwidth is the width of the each bar in xaxis of the score
             bar diagram.

             yticdiff is the difference of the tic levels in y axis of the
             bar diagram.


    Written By : Dileep Kumar.R, Arulalan.T

    Updated on : 28.09.2011

    """

    f = cdms2.open(path)
    filelist = path.split('/')[-1].split('_')
    seamon = filelist[-3].upper()
    # modelname
    modelname = filelist[-1].split('.')[0].upper()
    # year
    year = filelist[-2]
    # region
    regionName = filelist[-4]
    allvars = None
    if var == 'all':
        # var is all. So we have to take all the vars from passed ncpath.
        allvars = [var for var in f.listvariable() if not var.startswith('bounds')]
    else:
        if isinstance(var, list):
            allvars = var
        else:
            allvars = [var]

    if not outpath:
        # get the current workig directory
        outpath = os.getcwd()

    # setting some intelligent to set xaxis values and its labels depends on
    # no of threshold dynamically
    xdic = {}
    xval = []
    sno = 0
    i = 0
    while(i< len(threshold)):
        if sno % 2:
            # set xaxis threshold string
            xdic[sno] = str(threshold[i])
            i += 1
            xval.append(sno)
        else:
            # set xaxis empty string
            xdic[sno] = ''
        # end of if sno % 2:
        sno += 1
    # end of while(i< len(threshold)):
    # set final xaxis empty string
    xdic[sno] = ''
    # xaxis numpy value
    xval = numpy.array(xval)
    # xlist to set xaxis scales min, max value in xmgrace
    xlist = xdic.keys()
    xlist.sort()

    # make hours as int type and do sort
    hours = [int(hr) for hr in hours]
    hours.sort()
    # calculation and generating x axis shift alignments scales for
    # multiple hours bar for single threshold.
    # i.e. setting gap b/w each vertical bar for all the threshold(xaxis)bars
    rem = len(hours) / 2
    leng = rem * bargap
    bar_shift_list = numpy.arange(-leng, leng + bargap, bargap)
    bar_shift_list = [round(shift, 3) for shift in bar_shift_list]
    if len(hours) < len(bar_shift_list):
        centerindex = len(bar_shift_list) / 2
        bar_shift_list.remove(bar_shift_list[centerindex])
    # end of if len(hours) < len(bar_shift_list):

    # make fcst hour name in legend
    legendNames = []
    for hr in hours:
        day = hr / 24.0
        # keep as float if day is not 24's multiple
        if not hr % 24.0:
            day = int(day)
        day = 'D' + str(day)
        legendNames.append(day)
    # end of for hr in hours:

    # colorList is the list of colors of different bars corresponds
    # to forcast hours
    colorList = ['black', 'red', 'green', 'orange', 'maroon', 'blue', '	turquoise']
    org_yticdiff = yticdiff
    for varName in allvars:
        scoreName = varName.upper()
        # make reduce the yaxis tic lables for some scores
        if scoreName in ['ODR']:
            org_yticdiff = yticdiff
            yticdiff = yticdiff * 2
        else:
            # for other scores maintain the function definition value for
            # yticdiff variable
            yticdiff = org_yticdiff
        # create plot name directory if it is not exists
        scoreNamePath = createDirsIfNotExists(outpath, scoreName)
        # get the score data
        score = f(varName)

        try:
            title_string = score.long_name
        except:
            title_string = score.id

        # for condition checking purpose we get the data alone.
        nscore = numpy.array(score)

        # setting y axis min and max values depends upon the min, max of score
        if (numpy.min(nscore) < 0):
            Y_axis_min = int(numpy.min(nscore)) - yticdiff
        else:
            Y_axis_min = 0
        # end of if (numpy.min(nscore) < 0):
        if (numpy.max(nscore) > 1):
            Y_axis_max = int(numpy.max(nscore)) + 1
        else:
            Y_axis_max = 1
        # end of if (numpy.max(nscore) > 1):

        # setting y axis lables dynamically by find round max of score
        if Y_axis_max >= 1e+20:
            Y_second_max = numutils.nextmax(nscore)
            ydicmax = round(Y_second_max, 2)
        else:
            # change the max level into next to make good view in y axis
            Y_axis_max = Y_axis_max + yticdiff
            ydicmax = Y_axis_max
        ydicmax = (ydicmax-(ydicmax % yticdiff)) + yticdiff
        # get the min value of score
        ydicmin = nscore.min()

        if ydicmin < 0:
            if ydicmin == -1e+20:
                ydicmin = numutils.nextmin(nscore)
            # -ve value
            # adjust min value by rounding w.r.t yticdiff
            Y_axis_min = (ydicmin-(ydicmin % yticdiff)) - yticdiff
        else:
            Y_axis_min = 0
        Y_second_min = ydicmin
        # generate the ydic values
        ydicval = numpy.arange(Y_axis_min, ydicmax + yticdiff, yticdiff)

        ydic = {}
        for val in ydicval:
            ydic[val] = str(val)
        # setting some intelligent to set infinity in y axis label with
        # one interval after the second max of y axis
        if Y_axis_max >= (1e+20) or Y_axis_min <= (-1e+20):
            # setting infinity value
            ydicindex = ydic.keys()
            ydicindex.sort()
            for y in ydicindex:
                if y >= Y_second_max:
                    Y_axis_max = y + yticdiff
                    # add one more y axis label at next to next max val
                    # of yaxis scale
                    ydic[Y_axis_max] = str(Y_axis_max)
                    # set yaxis max val in yaxis lable for infinity case
                    Y_axis_max += yticdiff
                    # break
                # end of if y >= Y_second_max:
                if y <= Y_second_min:
                    Y_axis_min = y - yticdiff
                    # add one more y axis label at next to next max val
                    # of yaxis scale
                    ydic[Y_axis_min] = str(Y_axis_min)
                    # set yaxis max val in yaxis lable for infinity case
                    Y_axis_min -= yticdiff
                # end of if y >= Y_second_max:
            # end of for y in ydicindex:
            # change the y axis max val label by 'Infinity' for 1e+20 val in
            # score value
            ydic[Y_axis_max] = 'Infinity'
            ydic[Y_axis_min] = '-Infinity'
        # end of if Y_axis_max >= (1e+20):

        x = xmgrace.init()
        x.Graph[0].vymin = .20
        x.Graph[0].vymax = .90
        x.Graph[0].vxmin = .15
        x.Graph[0].vxmax = .88
        x.Graph[0].bar_hgap = 1
        x.Graph[0].status = 'on'

        x.Graph[0].title = title_string + ' ' + modelname + ' ' + year
        x.Graph[0].stitle = regions.get(regionName) + ' ' + seamon
        # ymin for graph 0
        x.Graph[0].yaxis.min = Y_axis_min
        # ymax for graph 0
        x.Graph[0].yaxis.max = Y_axis_max
        # Main tick every unit
        x.Graph[0].yaxis.tick.inc = 1
        # 4 sub in between, 1 every .25 units
        x.Graph[0].yaxis.tick.minor_ticks = 1
        x.Graph[0].yaxis.bar.status = 'on'
        # setting min value of x axis
        x.Graph[0].xaxis.min = xlist[0]
        # setting max value of x axis
        x.Graph[0].xaxis.max = xlist[-1]

        x.Graph[0].xaxis.tick.spec.loc = xdic
        x.Graph[0].xaxis.tick.label.char_size = .6
        x.Graph[0].xaxis.tick.orientation = 'out'
        x.Graph[0].xaxis.label = 'Rainfall Threshold (cm)'
        x.Graph[0].yaxis.tick.spec.loc = ydic
        x.Graph[0].yaxis.tick.label.char_size = .6
        x.Graph[0].yaxis.tick.orientation = 'out'

        x.Graph[0].yaxis.label = title_string
        x.Graph[0].legend.char_size = .7
        x.Graph[0].legend.x = .9  # Legend at 90% in x
        x.Graph[0].legend.y = .8  # Legend at 80% in y

        for setno in range(len(hours)):
            if setno != 0:
                x.add_set(0)
            # set bar type
            x.Graph[0].Set[setno].type = 'bar'
            # Set width of bar
            #x.Graph[0].Set[setno].symbol.size = 1.03
            x.Graph[0].Set[setno].symbol.size = barwidth
            # Set Color
            x.Graph[0].Set[setno].fill.color = colorList[setno]
            # Switch offing the line which connected on all the bars top edge
            x.Graph[0].Set[setno].line.type = 0
            # Setting the legend
            x.Graph[0].Set[setno].legend = legendNames[setno]
            # add the bar_shift_list elements to all the element of threshold
            xshiftval = xval + bar_shift_list[setno]
            # x axis values
            xshiftval = numpy.ma.array(xshiftval)
            # y axis values
            yval = numpy.ma.array(score(fcsthour = hours[setno])).squeeze()
            # Some statistical score takes values -1e+20, for plotting itmakes
            # some problem, threfore we are going to change -1e+20 as 0
            # (Theoriticaly it is not correct)
            # yval = numpy.ma.where(yval !=-1e+20, yval, 0)
            yval = numpy.ma.where(yval !=-1e+20, yval, Y_axis_min)
            # plot in xmgrace in the corresponding set of graph
            x.plot(yval, xshiftval, G = 0, S = setno)
            x.update()
        # end of for setno in range(len(hours)):

        output_filename = "%s_%s_of_%s_Region_%s_%s.jpg" % (modelname,
                                        scoreName, regionName, seamon, year)
        output_filename = scoreNamePath + '/' + output_filename
        x.jpeg(output_filename, color = 'color', quality = 80, dpi = 300,
                                         smoothing = 0, baseline = 'off')
    # end of for var in allvars:
    f.close()
# end of def genBarDiagrams(var, path, hours, outpath=None):

if __name__ == '__main__':

    for Model in models:
        xmlobj = xml_data_access.GribXmlAccess(Model.path)
        # get the model variable name from the global 'vars.txt'
        mvar = variables.get(Model.name).values()[0].model_var
        modeldataset = xmlobj[mvar, 'a']
        # get the timeAxis of modeldata set and correct its bounds
        modeltime = timobj._correctTimeAxis(modeldataset.getTime())
        # get the fully available months
        availableMonths = timobj.getTimeAxisFullMonths(modeltime)
        # calling func to generate season statiscore directories and its plots
        genSeasonStatiScoreDirs(Model.name, Model.hour, availableMonths)
        # close the xml objects
        xmlobj.closeXmlObjs()
    # end of for model in models:
    print "Done! Creation of all Bar diagrams plots"
# end of if __name__ == '__main__':
